namespace GenericParsingLibrary;

/// <summary>
/// The type of token to check when parsing.
/// <para/>
/// They can be interpreted in any way desired and overlapping types
/// exist purely for convenience, e.g. Boolean and Keyword exist even though
/// a boolean may be a keyword.
/// </summary>
public enum TokenType
{
    /// <summary>
    /// An identifier is generally a word that does not contain whitespace, symbols or quotes.
    /// </summary>
    Identifier,
    /// <summary>
    /// A keyword is a special word that cannot be used as an identifier but usually follows the same rules as an identifier.
    /// </summary>
    Keyword,
    /// <summary>
    /// A symbol a char or small string that has a special purpose in a language. E.g. '=', '>=', '{', '}'
    /// </summary>
    Symbol,
    /// <summary>
    /// A string is a set of characters enclosed between matching symbols, e.g. "This is a string"
    /// </summary>
    String,
    /// <summary>
    /// A number is a generic version of the more specific types (like <see cref="Integer"/>.
    /// It can be used if all numbers resolve to a single type.
    /// </summary>
    Number,
    /// <summary>
    /// An integer is a whole number with no decimal places.
    /// </summary>
    Integer,
    /// <summary>
    /// A float is usually a number with decimal places.
    /// </summary>
    Float,
    /// <summary>
    /// A decimal is a general version of a float and can be used to denote floating point numbers of higher precision.
    /// </summary>
    Decimal,
    /// <summary>
    /// A boolean is 'true' or 'false'.
    /// </summary>
    Boolean,
    /// <summary>
    /// Whitespace is the "empty" space between characters and is usually not captured, but some languages might make use of it, e.g. Python.
    /// </summary>
    WhiteSpace,
    /// <summary>
    /// A comment is a message left by programmers.
    /// </summary>
    Comment
}

/// <summary>
/// Holds information about a token encountered during the tokenization process.
/// Generated by <see cref="GenericTokenizer"/> or a sub class.
/// </summary>
public interface IToken
{
    /// <summary>
    /// Gets the type of the token. Used mostly with parser 'Eat' methods.
    /// </summary>
    public TokenType TokenType { get; }
    /// <summary>
    /// Gets the value of the token as a string.
    /// This should be converted to the desired type in your parsing class.
    /// </summary>
    public string Value { get; }
    /// <summary>
    /// Gets the index this token was encountered at in the source string.
    /// </summary>
    public int Index { get; }
    /// <summary>
    /// Gets the line number in the source string that this token was encountered at.
    /// </summary>
    public int LineNumber { get; }
    /// <summary>
    /// Gets the line position on the line in the source string this token was encountered at.
    /// </summary>
    public int LinePosition { get; }
}
